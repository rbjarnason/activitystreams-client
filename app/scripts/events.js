'use strict';
var root, trigger;

root = typeof exports !== "undefined" && exports !== null ? exports : this;

root.ActivitySnippet = typeof ActivitySnippet !== "undefined" && ActivitySnippet !== null ? ActivitySnippet : {};

ActivitySnippet.Events = (function() {
  function Events() {}


  /**
   * A class that allows simple message passing
   * There needs to be a 'transport' object that will maintain
   * the list of channels and listeners. Based on Backbone's
   * events module.
   */


  /**
   * Pushes callbacks and context to an event object collection
   *  with a channel namespace
   * @param  {string}   channel  the channel / namespace to listen to
   * @param  {Function} callback the callback function
   * @param  {object}   context  context 'this' used when calling the callback
   */

  Events.prototype.on = function(channel, callback, context) {
    var events;
    if (!callback) {
      return this;
    }
    this._events = this._events || {};
    events = this._events[channel] || (this._events[channel] = []);
    events.push({
      callback: callback,
      context: context,
      ctx: context || this
    });
    return this;
  };

  Events.prototype.off = function(name, callback, context) {
    var event, events, names, retain, _i, _j, _len, _len1;
    if (!this._events) {
      return this;
    }
    if (!name && !callback && !context) {
      this._events = void 0;
      return this;
    }
    names = name ? [name] : Object.keys(this._events);
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      if (events = this._events[name]) {
        this._events[name] = retain = [];
        if (callback || context) {
          for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
            event = events[_j];
            if ((callback && callback !== event.callback) || (context && context !== event.context)) {
              retain.push(event);
            }
          }
        }
        if (!retain.length) {
          delete this._events[name];
        }
      }
    }
    return this;
  };


  /**
   * Allows the object you calling this on to register a callback with a transport object
   * @param  {Object}   transport the transport object that will contain the messages
   * @param  {string}   channel   namespaced channel/event you wish to listen to
   * @param  {Function} callback callback that will be fired when the an event has been sent to the channel
   */

  Events.prototype.listenTo = function(transport, channel, callback) {
    var id, listeningTo;
    listeningTo = this._listeningTo || (this._listeningTo = {});
    id = transport._id || (transport._id = (new Date()).getTime());
    listeningTo[id] = transport;
    transport.on(channel, callback, this);
    return this;
  };

  Events.prototype.stopListening = function(transport, name, callback) {
    var id, listeningTo, remove;
    listeningTo = this._listeningTo;
    if (!listeningTo) {
      return this;
    }
    remove = !name && !callback;
    if (transport) {
      (listeningTo = {})[transport._id] = transport;
    }
    for (id in listeningTo) {
      transport = listeningTo[id];
      transport.off(name, callback, this);
      if (remove || !Object.keys(transport._events).length) {
        delete this._listeningTo[id];
      }
    }
    return this;
  };


  /**
   * determines what namespaced event callbacks should be fired
   *
   * @param  {string} name namespaced channel/event
   * @param  {object} arg argument object passed to the calllback
   */

  Events.prototype.trigger = function(name, arg) {
    var allEvents, events;
    if (!this._events) {
      return this;
    }
    events = this._events[name];
    allEvents = this._events["*"];
    if (events) {
      trigger(events, arg, name);
    }
    if (allEvents) {
      trigger(allEvents, arg, name);
    }
    return this;
  };

  return Events;

})();


/**
 * Triggers all callbacks registered to a specfic channel
 * @param  {object} events collection of event objects 
 * @param  {object} arg     arg object to pass to the callback
 * @param  {strign} name    the name of the namespaced event
 */

trigger = function(events, arg, name) {
  var event, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = events.length; _i < _len; _i++) {
    event = events[_i];
    _results.push(event.callback.call(event.ctx, arg, name));
  }
  return _results;
};

// ---
// generated by coffee-script 1.9.0
